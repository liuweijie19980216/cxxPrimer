# 第3章 字符串、向量、数组
## 3.1 命名空间using声明

使用`using`声明无须专门的前缀就能使用所需的名字。
```c++
using namespace::name;
```

- 每个名字都需要独立的using声明，而且每句话都要以分号结束。

- 头文件不应该包含`using`声明，防止产生名字冲突。
  
## 3.2 标准库类型`string`
`string`表示可变长的字符序列。

### 3.2.1 定义和初始化`string`对象
```c++
string s1;  // 默认初始化，s1是一个空字符串
string s2; // s2是s1的副本
string s3 = "hiya";  // s3是该字符串字面值的副本
string s4(10, 'c');   // s4的内容是cccccccccc
```

使用字符串字面值初始化`string`对象时，会除了字面值最后的空字符。

**直接初始化和拷贝初始化**

使用等号是拷贝初始化，编译器把等号右侧的初始值拷贝带新创建的对象中去。不使用等号是直接初始化。

### 3.2.2 `string`对象上的操作
- os << s：将s写到输出流os当中，返回os
- is >> s：从is读取字符串赋给s，字符串以空白分隔，返回s
- getline(is, s)：从is中读取一行赋给，返回is
- s.empty()：s为空返回true
- s.size()：返回s中字符的个数
- s[n]：返回s中第n个字符的引用
- s1 + s2：返回s1和s2拼接后的结果
- s1 = s2：用s2的副本替代s1中原有的字符
- s1 == s2：二者字符完全一样，返回true
- s1 != s2：二者字符不一样，返回true
- <, <=, >, >= ：利用字符在字典中的顺序进行比较

**读写`string`对象 **

```c++
string s;
cin >> s;
cout << s;
```
**读取未知数量的`string`对象**
```c++
string word;
while(cin >> word)
    cout << word;
```

**使用`getline`读取一整行**

`getline`一遇到换行符就结束读取操作并返回结果。
```c++
string line;
while(getline(cin, line))
    cout << line << endl;
```

**`string`的`empty`和`size`操作**

`string.empty()`判断`string`是否为空，`string.size()`判断`string`中字符的个数。

**string::size_type类型**

`size`函数返回的是一个`string::size_type`类型的值。它是一个无符号类型的值，而却足够存放下任务`string`对象的大小。允许编译器通过`auto`和`decltype`来推断变量的类型。

不能混用无符号类型和有符号类型的变量，如果将`string::size_type`与一个负整数比较，永远会是负整数大，因为负值会自动转换成一个比较大的无符号值。

注意：如果表达式中已经有了`size()`函数就不要再使用`int`了。

**比较`string`对象**

比较运算符逐一比较`string`对象中的字符，并且对大小写敏感。

1. 如果较短`string`和较长`string`对应位置相同，则较短`string`小于较长`string`
2. 如果两个`string`在某些位置上不一致，那`string`对象比较的结果是第一对不同字符串比较的结果。

**为`string`类型赋值**

允许一个`string`对象赋值给另一个`string`对象。

**两个`string`对象相加**

两个`string`拼接成一个新的`string`对象。

**字面值和`string`对象相加**

必须确保加法运算符两侧的运算对象至少有一个是`string`。

字符串字面值和`string`是不同的类型。

### 3.2.3 处理`string`对象中的字符

cctype头文件中的函数
- isalnum(c)：当c时字母或数字时为真
- isalpha(c)：当c是字母时为真
- iscntrl(c)：当c是控制字符时为真
- isdigit(c)：当c是数字时为真
- isgraph(c)：当c不是空格但可打印时为真
- islower(c)：当c是小写字母时为真
- isprint(c)：当c是可打印字符时为真
- ispunct(c)：当c是标点符号时为真
- isspace(c)：当c是空格是为真
- isupper(c)：当c是大写字母时为真
- isxdigit(c)：当c是十六进制数字时为真
- tolower(c)：转换为小写字母
- toupper(c)：转换为大写字母

C++程序中应该使用cname的头文件而不是使用name.h的形式，标准库中的名字总能在命名空间std中找到。

**使用基于范围的for语句**
```c++
for(declaration: expression)
    statement
```
其中，expression部分是一个对象，用来表示一个序列。declaration部分负责定义一个变量，用来访问序列中的基础元素。
```c++
string str("some string");
for(auto c: str)
    cout << c << endl;
```

使用范围for语句和ispunct来统计`string`对象中标点符号的个数：
```c++
string str("Hello World!!!");
decltype(s.size()) punct_cnt = 0;
for(auto c: str)
    if (ispunct(c))
        ++punct_cnt;
cout << punct_cnt << endl;
```

**使用范围for语句改变字符串中的字符**

如果想要改变`string`对象中字符的值，必须报循环变量定义成引用类型。

**只处理一部分字符**

要想访问`string`对象中的单个字符有两种方式：一种是使用下标，另一种是使用迭代器。

**下标运算符**`[]`接受的参数是`string::size_type`类型的值，返回值是该位置上字符的引用。

注意事项：
- `string`对象的下标必须大于0而小于`s.size()`，否则会引发不可预知的后果
- 在访问指定字符之间，首先检查`s`是否为空，如果`s`为空，`s[0]`的结果将是未定义的。

**使用下标执行迭代**

```c++
for(decltype(s.size()) index = 0; 
    index != s.size() && !isspace(s[index]); ++index)
        s[index] = toupper(s[index]);

```

上面的程序中，逻辑与运算符`&&`左侧先保证了`index`不会等于`s.size()`，随意右侧访问字符串就不可能会越界。

注意检查下标的合法性。一种简单的方法是，总是设下标的类型为`string::size_type`，这样只要缺表下标小于`s.size()`就可以了。

**使用下标执行随机访问**

可以通过下标直接访问某个字符。注意，无论何时使用字符串的下标，都是检查其合法性。

## 3.3 标准库类型`vector`

标准库类型`vector`表示对象的集合，其中所有对象的类型都相同。C++既有类模板，也有函数模板，其中`vector`是一个类模板。

对于类模板而言，我们需要提供一些额外的信息来指定模板到底实例化成什么样的类，需要提供那些信息由模板提供。

对于`vector`而言，提供的额外信息是`vector`内所存放对象的类型。

### 3.3.1 定义和初始化`vector`对象
可以默认初始化`vector`对象，从而创建一个指定类型的空`vector`。

**列表初始化`vector`对象**
```c++
vector<string> articles = {"a", "an", "the"};
vector<string> articles{"a", "an", "the"};
```
在大多数情况下，不同的初始化方式可以等价使用，除了以下几种例外：
- 使用拷贝初始化时，只能提供一个初始值
- 如果提供的是一个类内初始值，则只能使用拷贝初始化或者花括号的形式初始化
- 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。

**创建指定数量的元素**
```c++
vector<int> ivec(10, -1);  // 10个int类型的元素，每个都被初始化为-1
```

**值初始化**
可以只提供`vector`对象容纳的元素数量而略去初始值，此时库会创建一个值初始化元素初值。这种初始化方式有两个限制：
- 有些类必须明确要求提供初始值，则必须提供初始的元素值
- 只能使用直接初始化

**列表初始化还是元素数量？**

通过花括号或圆括号来区分括号中是元素数量还是初始值。

```c++
vector<int> v1(10);  // v1中有10个元素，被默认初始化为0
vector<int> v2{10};  // v2有1个元素，该元素的值是10

vector<int> v3(10, 1);  // v3中有10个元素，每个元素的值都是1
vector<int> v4{10, 1};  // v4中有2个元素，值分别为10和1
```

如果使用的是圆括号，可以说提供的值是用来构造`vector`对象的。

如果使用的是花括号，初始化过程会尽可能地把花括号内的值当值元素初始值来处理。当花括号里面的值不能用来列表初始化，就考虑用这样的值来构造`vector`对象了。

### 3.3.2 向`vector`对象中添加元素
创建一个`vector`对象时并不清楚所需元素的个数，更好的做法是先创建一个空`vector`，然后在运行时利用`vector`的成员函数push_back向其添加元素。

**关键概念：`vector`对象能高效增长**

定义`vector`对象时先定义一个空的`vector`对象，运行时再往里面添加元素。如果定义时设定其大小，性能可能更差。

**向vector对象添加元素蕴含的编程假定**

如果循环体内包含有向`vector`对象添加元素的语句，则不能使用范围for循环。范围for循环语句体内不应该改变其所遍历序列的大小。这是因为改变`vector`对象中的元素可能会导致末尾迭代器失效，循环无法跳出变成死循环。

### 3.3.3 其他vector操作

除了成员函数`push_back`之外，`vector`的大多数操作都与`string`相同。只有当元素的值可比较时，`vector`对象才能被比较。

**计算`vector`内对象的索引**

使用下标运算符能获取到指定的元素，也能通过计算得到`vector`内对象的索引，然后直接获取索引位置上的元素。

**不能使用下标形式添加元素**

`vector`对象和`string`对象的下标运算符可用于访问已经存在的元素，而不能用于添加元素。

只能对确知已存在的元素执行下标操作。确保下标合法的一种有效手段就是尽可能使用范围for语句。

## 3.4 迭代器介绍

前面已经学习过可以通过下标访问string和vector中的元素，但对于大多数的容器来说，并不主持下标访问。而迭代器是一种更加通用的机制，可以访问所有标准库容器中的元素。

迭代器和指针类似，可以间接访问对象。有效的迭代器要么指向某个元素，要么指向容器尾元素的下一个位置。

### 3.4.1 使用迭代器
有迭代器的类型都用来返回迭代器的成员函数。
```c++
auto b = v.begin(), e = v.end();
```
begin返回的是容器的第一个元素，end返回的是尾后一个元素，没有实际元素，只是一个标记。当容器为空时，begin和end返回的是同一个迭代器，都是尾后迭代器。

**迭代器运算符**
- *iter 返回迭代器所指元素的引用
- iter->mem 等价于（*iter）.mem
- ++iter 令iter指向容器的下一个元素
- --iter 令iter指向容器的上一个元素
- iter1 == iter2，iter1 != iter2 两个迭代器是否指向同一个元素

和指针类似，执行解引用的迭代器必须合法并确实指示着某个元素。

**将迭代器从一个元素移动到另外一个元素**

使用自增运算符将迭代器后移。因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。

将string对象中第一个单词改为大写形式：
```c++
for(auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
 *it = toupper(*it);
```

**泛型编程**

所有的标准库容器都支持迭代器，尽量养成循环中使用迭代器的习惯而不是下标，这样可以不用在意容器的类型。

**迭代器类型**

那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型。const_iterator不能改变迭代器所指对象的值，如果是常量容器，必须定义const_iterator。
```c++
vector<int>::iterator it;
string::iterator it;
```
每个容器定义了一个名为iterator的类型，该类型支持迭代器概念所规定的一套操作。

**begin和end操作**
如果对象是常量，返回的是const_iterator，如果不是常量，返回的是iterator。

如果需要自己定义返回的迭代器类型，使用cbegin和cend，不管容器的类型是什么，返回的都是const_iterator。

**结合解引用和成员访问操作**

C++定义了箭头运算符(->)，把解引用和成员访问两个操作结合在一起。也就是说，it->item和(*it),item表达的意思相同。

**某些对vector对象的操作会使迭代器失效**

任何一种可能改变vector对象容量的操作，都会是vector对象的迭代器失效。谨记，凡是使用了迭代器的循环体，都不要向迭代器所属的容器中添加元素。

### 3.4.2 迭代器运算
所有标准库容器都支持递增递减，==，!=运算的迭代器，但是string和vector还额外支持一些其他的操作。
- iter + n 迭代器向前移动n个位置
- iter - n 迭代器向后移动n个位置
- iter += n
- iter -= n
- iter1 - iter2 两个迭代器之间的距离，必须指向同一个容器
- `> >= < <=` 比较两个容器的位置，必须指向一个容器

**迭代器的算术运算**

```c++
auto mid = vi.begin() + v1.size() / 2;
if(it < mid)
    // 处理vi前半部分的元素
```

两个迭代器相减所得到的数据类型是difference_type的带符号整型。

**使用迭代器运算**

二分搜索从有序序列中寻找某个给定的值。
```c++
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2;

while(mid != end && *mid != sought)
{
    if (sought < mid>)
        end = mid;
    else
        beg = mid + 1;
    mid = beg + (end - beg) / 2;
}
```

## 3.5 数组
数组是一种类似于标准库类型vector的数据结构，数组也是存放类型相同的对象的容器。不同的是，数组的大小固定。

### 3.5.1 定义和初始化内置数组
数组是一种复合类型，数组的声明形如a[d]，d是数组的维度，必须是一个常量表达式。

定义数组时必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。

**显式初始化数组元素**

- 声明时没有指明维度，编译器会根据初始值的数量推断出来
- 如果指明了维度，初始值数量不能超过维度
- 维度比提供的数值大，剩下的元素被初始化为默认值。

**字符数组的特殊性**

可以使用字符串字面值初始化字符数组，但是要注意字符串字面值最后有一个空字符也会被拷贝到数组中。

**不允许拷贝和赋值**

不能将数组的内容拷贝给其他数组

**理解复杂的数组声明**
```c++
int *ptrs[10];  // ptrs是含有20个整型指针的数组
int &refs[10];  // 错误，数组不保存引用
int (*Parray)[10] = &arr;  // Parray指向一个包含10个整数的数组
int (&arrRef)[10] = arr; // arrRef是一个包含了10个整数数组的引用
int *(&array)[10] = ptrs;  // array是一个长度为10的数组的引用，数组中保存的是整型指针
```

### 3.5.2 访问数组元素
在使用数组下标的时候，通常将其定义为size_t类型。数组除了大小固定这一特点外，其他用法与vector基本类似。

**检查下标的值**

要小心检查下标的值防止下标越界。

### 3.5.3 指针和数组
对数组的元素使用取地址符就能得到指向该元素的指针。

在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针。在大多数的表达中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。但是decltype返回类型依然是数组。
```c++
int ia[] = {1, 3, 4}
decltype(ia) ia3 = {3, 5, 6}  // ia3是一个含有10个整数的数组
```

**指针也是迭代器**

指向数组元素的指针拥有和vector,string迭代器相同的功能，包括前移，后移，获取尾后指针。

**标准库函数begin和end**

尽管能计算得到尾后指针，但是这种用法极容易出错。C++11引入了名为begin和end的函数，这两个函数的功能与迭代器的同名成员函数基本相同。

特别注意，尾后指针不能进行解引用和递增操作。

**指针运算**

指向数组的指针运算与vector，string迭代器完全相同。

两个指针相减的结果的类型是ptrdiff_t的标准库类型。

只要两个指针指向相同的数组，就可以进行比较。如果分别指向不相关的对象，则不能比较，因为比较没有意义。

**解引用和指针运算的交互**

指针加上一个整数所得的结果还是一个指针，如果结果指针指向一个元素，可以解引用该指针：
```c++
int ia[] = {0, 2, 4, 6, 8};
int last = *(ia + 4);  // last初始化为8
```

**下标和指针**

对数组执行下标运算其实是对指向数组元素的指针执行下标运算。

只要指针指向的是数组中的元素或者尾后元素，就可以使用下标运算。
```c++
int ia[] = {0, 2, 4, 6, 8};
int i = ia[2];

int *p = &ia[2];  // p指向索引为2的元素
int j = p[1];  // p[1]是ia[3]中的元素
int k = p[-2];  // p[-2]是ia[0]中的元素
```

标准库类型限定使用的下标必须是无符号类型，内置的下标运算符无此要求。

### 3.5.4 C风格字符串
字符串字面值是从C继承而来的C风格字符串。字符串存放在字符数组中并以空字符结束('\0')，一般利用指针来操作这些字符串。

**C标准库String函数**

- strlen(p)：返回p的长度，不包含空字符
- strcmp(p1, p2)：p1,p2相等返回0；p1>p2返回正值
- strcat(p1, p2)：将p2附加到p1之后，返回p1
- strcpy(p1, p2)：将p2拷贝给p1，返回p1

传入此类函数的指针必须指向以空字符作为结束的数组

**比较字符串**

前面String类型的字符串可以直接用比较运算符，但C风格字符串保存在字符数组，使用数组时实际使用的是指向首元素的指针，使用比较运算符会变成比较指针。所以C风格字符串的对比需要用到函数strcmp()。

**目标字符串的大小由调用者指定**

使用strcpy和strcat函数时，需要提供一个用于存放结果字符串的数组，该数组的大小要求足够大能够存放结果字符串。

如果计算错了结果字符串的大小将引发严重错误。

### 3.5.5 与旧代码的接口
为了使C++程序能够与那些充满了数组或C风格字符串的代码衔接，专门提供了一组功能。

**混用string对象和C风格字符串**

- 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值
- 在与string对象运算中，以空字符结束的字符数组会被自动转为string类型
  
但是上述对象反过来不成立，也就是说，需要用到C风格的字符串，不能用string对象代替。

string提供了一个成员函数c_str，返回一个C风格的字符串，实际的类型是const char*，确保我们不会改变字符数组的内容。

如果后续的操作改变了string对象的内容，之前返回的字符数组可能失效。如果执行完c_str函数后想一直使用其返回的数组，最好将该数组重新拷贝一份。

**使用数组初始化vector对象**

不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。但是，可以用数组初始化vector对象

```c++
int int_arr[] = {0, 1, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));  // 拷贝首元素地址和尾后地址就可以

```

# 3.6 多维数组

C++实际上没有多维数组，通常说的多维数组就是数组的数组。

**多维数组的初始化**

允许使用花括号括起来的一组值初始化多维数组。

```c++
int ia[2][3] = {
    [1, 2, 3],
    [2, 4, 5]
};

// 可以不写嵌套的花括号
int ia[2][3] = {1, 2, 3, 2, 4, 5};

// 显式初始化每行的首元素，未列出的元素默认值初始化
int ia[2][3] = {{1}, {2}, {3}};

// 显式初始化第一行，其他元素默认值初始化
int ix[2][3] = {1, 2, 3}
```

**多维数组的下标引用**

例如，程序中经常会用两层嵌套for循环处理多维数组的元素：
```c++
constexpr size_t rowCnt = 3; colCnt = 4;
int ia[rowCnt][colCnt];
for(size_t i = 0; i != rowCnt; ++i)
{
    for(size_t j = 0; j != colCnt; ++j)
    {
        ia[i][j] = i * colCnt + j;
    }
}

```

**使用范围for语句处理多维数组**

要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。这是为了避免程序自动地将数组变成指向首元素的指针，这样会导致内层循环不合法。

**指针和多维数组**

由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：
```c++
int ia[3][4];
int (*p)[4] = ia;  // p指向含有4个整数的数组
p = &ia[2];  // p指向ia的尾元素

```

使用auto和decltype就可以避免在数组前面加一个指针类型。或者使用标准库函数begin和end。

**类型别名简化多维数组的指针**

```c++
using int_array = int[4];
typedef int int_array[4];
```

程序将包含4个整数的数组命名为int_array。