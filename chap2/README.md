# 第2章 变量和基本类型
## 2.1 基本内置类型

C++定义了两种基本数据类型，**算术类型**和**空类型**。

### 2.1.1 算术类型

算术类型分为两类，**整型**和**浮点型**。

算术类型的尺寸在不同机器上有所差别。

|    类型     |      含义      |   最小尺寸    |
| :---------: | :------------: | :-----------: |
|    bool     |    布尔类型    |    未定义     |
|    char     |      字符      | 8位（1字节）  |
|   wchar_t   |     宽字符     | 16位（2字节） |
|  char16_t   |  Unicode字符   | 16位（2字节） |
|  char32_t   |  Unicode字符   | 32位（4字节） |
|    short    |     短整型     | 16位（2字节） |
|     int     |      整型      | 16位（2字节） |
|    long     |     长整型     | 32位（4字节） |
|  long long  |     长整型     | 64位（8字节） |
|    float    |  单精度浮点型  |  6位有效数字  |
|   double    |  双精度浮点数  | 10位有效数字  |
| long double | 扩展精度浮点数 | 10位有效数字  |

一个char的空间确保可以存放机器基本字符集中任意字符对应的数字值。

对于扩展字符集，使用wchar_t等。

**带符号类型和无符号类型**

除了布尔型和扩展的字符集，其他整型都可以划分为**带符号（signed）**和**无符号（unsigned）**两种。

- 类型int shot long 和long long都是带符号的，类型名前面加上unsigned就是无符号类型。
- 字符型被分为三种，char、signed char和unsigned char。char具体是有符号还是无符号由编译器决定。

**数据类型选取建议**

- 尽量使用无符号类型。
- 如果数值超过int，使用long long。
- 算术表达式中不用char和bool。如果需要不大的整数，给char指明是否带符号。
- 执行浮点数计算使用double。

### 2.1.2 类型转换

算术类型转换过程中需要注意以下几点：

- 将整数转换为浮点数，通常小数部分记为0。如果整数所占空间超过了浮点数，整数精度可能会损失。
- 不能赋给无符号类型一个超出它表示范围的值。否则结果是初始值对无符号类型表示数值总数取模后的余数。
- 如果赋给带符号类型一个超出它表示范围的值，结果是未定义的。

**含有无符号类型的表达式**

如果一个算术表达式中既有带符号也有无符号，带符号数会自动被转换为无符号数，这也相当于将带符号整数赋值给无符号，这样会得到不符合预期的结果。因此，**不要在表达式中混用带符号和无符号数。**

### 2.1.3 字面值常量

一个形如42的值被称为字面值常量。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

**整型和浮点型字面值**

- 整型字面值可以用十进制，八斤重、十六进制数来表示。0开头的用来表示八进制，0x或者0X开头表示十六进制。

- 浮点型字面值可以由小数或者科学计数法的形式来表现，浮点型字面值默认是一个double。

**字符和字符串字面值**

- 单引号括起来的一个字符表示字符字面值。
- 双引号括起来的表示字符串字面值，实际上是由常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符'\0'。
- 两个字符串字面值由空格、缩进和换行分隔，实际上是一个字符串。

**转义序列**

遇到**不可打印**以及有**特殊含义**的字符，就需要使用转义序列，转义序列均以反斜线作为开始。

- 换行符  \n
- 横向制表符 \t
- 反斜线 \\\  等等

在程序中，上述转义序列被当作一个字符使用。

还可以使用泛化的转义序列，\x后紧跟十六进制数字（一个或者多个），\后紧跟八进制数字（最多三个），数字部分表示的是字符对应的数值。

**指定字面值类型**

可以在字面值常量上面加上前缀或者后缀，指定其对应的数据类型。

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。

### 2.2.1 变量定义

**初始值**

当对象在创建时获得初始值，我们说这个对象被**初始化**了。在同一条定义语句中，可以用先定义的变量去初始化后定义的变量。

**注意**：初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象当前值擦除，以一个新值代替。

**列表初始化**

C++定义了初始化的多种形式，以下4条语句都可以初始化一个int类型的变量：

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

用花括号初始化变量称为列表初始化。这种初始化方式有一个特点：如果使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。

**默认初始化**

如果定义变量时没有指定初值，则变量被默认初始化。对于内置类型而言，定义于任何函数之外的变量被初始化为0，定义于函数体内部的变量**不被初始化**。类的对象如果没有显式地初始化，其值由类决定。

### 2.2.2 变量声明和定义的关系

**声明**使得名字为程序所知，**定义**负责创建与名字关联的实体。变量声明规定了变量的类型和名字，定义还需要申请存储空间，也可能会为变量赋一个初始值。

```c++
extern int i;  // 声明，extern用来显式地声明变量
int j;  // 声明并定义
extern double pi = 3.1416;  // 定义，显示初始化变量会抵消extern的作用
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

变量只能被定义一次，但可以被多次声明。

### 2.2.3 标识符

C++的标识符由字母、数字和下划线组成，并且必须由字母或者下划线开头。长度没有限制，对大小写敏感。

用户自定义的标识符还有一些注意事项：

- 不能连续出现两个下划线
- 不能以下划线紧连大写字母开头
- 定义在函数体以外的标识符不能以下划线开头

### 2.2.4 名字的作用域

作用域是程序的一部分，在其中名字有其特定的含义。C++中大多数作用域都是以花括号分割。

名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

定义在函数体外的名字拥有**全局作用域**，定义在函数体内部的名字有**块作用域**。

建议：一般来说，在对象第一次被使用的地方附近定义它是一种好的选择。

**嵌套的作用域**

作用域能彼此包含，被包含的作用域称为**内层作用域**，包含着别的作用域的作用域称为**外层作用域**。

可以通过域操作符`::`显示地访问全局变量。

## 2.3 复合类型
复合类型是指基于其他类型定义的类型。本章主要介绍两种：引用和指针。
声明语句更通用的描述是：一条声明语句由一个**基本数据类型**和紧随其后的一个**声明符**列表组成。
### 2.3.1 引用
引用给对象起了另外一个名字，声明符是&d，其中d是声明的变量名。

定义引用时，程序把引用和它的初始值**绑定**在一起。一旦初始化完成，引用和它的初始值对象一直绑定在一起。引用无法绑定到另一个对象，因此引用必须初始化。

**引用即别名**：引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

引用本身不是对象，所以不能定义引用的引用。

引用只能绑定在对象上，而不能与某个字面值或表达式的结果绑定在一起。
### 2.3.2 指针
指针是指指向另外一种类型的复合类型。指针与引用主要有两点区别：
- 指针本身就是一个对象，生命周期内可以先后指向多个不同的对象。
- 定义时无需赋初值。块作用域内没有被初始化，会拥有一个不确定的值。
  
**获取对象的地址**

使用取地址符&获取某个对象的地址

**利用指针访问对象**

如果指针指向一个对象，使用解引用符*来访问该对象。解引用操作仅适用于那些指向了某个对象的有效指针。访问无效指针的后果是不可估计的。

**空指针**

空指针不指向任何对象，在试图使用一个指针之前代码可以检查它是否为空。下面是一些定义空指针的方法：
```c++
int *p1 = nullptr;  // nullptr是一种特殊的字面值，可以转换成任意的指针类型
int *p2 = 0;
int *p3 = NULL;  // 预处理变量
```
建议初始化所有的指针。

**赋值和指针**

给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。

**指针的其他操作**

只要指针拥有一个合法值，就能用在条件表达式中。如果指针的值是0，条件就是false.

两个类型相同的合法指针，可以使用比较操作符来比较两个指针所存放的地址。

**void\* 指针**

void*是一种特殊的指针类型，可以存放任意对象的地址，我们不了解地址中是什么类型的对象。不能直接操作void\*指针所指向的对象，因为我们不知道对象的数据类型。

### 2.3.3 理解复合类型的声明

在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。类型修饰符（*，&）是声明符的一部分。

**定义多个变量**

在定义语句中，类型修饰符（*，&）仅用来修饰最邻近的变量，而不是本次定义的全部变量。

**指向指针的指针**

指针是内存中的对象，有自己的地址，允许把指针的地址再存放在另一个指针当中。通过*的个数可以区分指针的级别。
```c++
int ival = 1024;
int *pi = &ival;  // pi指向int类型数
int **ppi = &pi;  // ppi指向int类型的指针
```

**指向指针的引用**

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在指针的引用。

```c++
int i = 42;
int *p;
int *&r = p;  // r是对指针p的引用

r = &i;  // 取i的地址，赋值给指针p
*r = 0;  // r与p是绑定的，*r就是解引用p，给i赋值0
```

面对一条比较复杂的指针或者声明语句，从右往左读更有助于理解它的真实含义。`int *&r`首先是一个引用，左边的`\*`表示是一个对指针对象的引用,最左边的`int`表示是一个对int类型指针对象的引用。

## 2.4 限定符

定义一种值不能被改变的变量，使用关键字`const`对变量的类型加以限定。

由于`const`对象一旦创建后就不能再改变，所以`const`对象必须初始化。

**初始化和`const`**

如果用一个`const`对象去初始化另外一个对象，则它们是不是`const`都无关紧要。也就是说，可以将`const`对象赋值给非`const`对象，这时候无需在意`const`的限定作用。

**默认状态下，`const`对象仅在文件内有效**

每一个用到`const`对象的文件都要包含对它的定义，为了避免重复定义，默认情况下，`const`对象被设定为仅在文件内有效。当多个文件中出现多个同名的`const`变量，则等同在不同文件中分别定义了独立的变量。

如果要在多个文件之间共享`const`变量，不管是定义还是声明，都需要在前面加上关键字`extern`。

### 2.4.1 const的引用

可以把引用绑定到`const`对象上，我们称之为对常量的引用。对常量的引用不能用作修改它所绑定的值，也不能让一个非常量引用指向一个常量对象。

**初始化和对`const`的引用**

引用的类型必须与其所引用对象的类型一致，但是有两个例外。
- 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用类型即可。
- 允许为一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式。

**对`const`的引用可能引用一个并非`const`的对象**

常量引用仅仅对引用可参与的操作做出了限定，对于引用本身是不是常量未作限定，可以通过其他的途径改变它的值。

### 2.4.2 指针和`const`

指针是对象而引用不是，允许把指针本身定为常量，我们称为**常量指针**。常量指针必须被初始化，初始化之后常量指针保存的地址就不能再改变了。

*放在const前面说明指针是一个常量，也就是说，不变的是常量本身而不是常量指向的值。

指针本身是一个常量并不意味着不能通过指针改变其所指向的值，能否改变指针所指向的值取决于指针所指向对象本身的类型。

**总结：**
- 常量指针。定义形式为`int *const p = &i;`表示指针本身是一个常量，初始化后就不能改变指针所保存的地址。
- 指针常量。 定义形式为`const int *p = &i;`表示指针指向一个常量值，不能通过指针改变所指向的那个变量，但是可以改变指针常量所指向的地址。

### 2.4.3 顶层const

使用名词顶层const表示指针本身是一个常量，底层const表示指针所指的对象是一个常量。顶层const也就是常量指针，底层const是指针常量。

当执行拷贝操作是，常量时顶层const还是底层const区别明显。其中，顶层const不受什么影响（变量本身是常量，可以赋值给常量，也可以赋值给非常量），但是底层const的限制却不能忽略。
```c++
const int ci = 42;
const int *p2 = &ci;  // 底层const
const int *const p3 = p2;  //底层和顶层const
int *p = p3;  // 错误，p3指向的是const类型的变量，不能赋值给普通的指针p
```

当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换，非常量可以转换为常量，反过来不行。

### 2.4.4 constexpr和常量表达式
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。字面值是常量表达式，用常量表达式初始化的const对象也是常量表达式。

语句`const int sz = get_size();` 中的`sz`不是常量表达式，因为它的具体数值在运行时才能获取到。

**constexpr变量**
在一个复杂的系统中，很难分辨一个初始值是不是常量表达式。可以将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化。

尽管不能用普通函数作为`constexpr`变量的初始值，但可以定义一种特殊的`constexpr`函数去初始化`constexpr`变量。但是`constexpr`函数需要足够简单，在编译时就能得到结果。

**字面值类型**

声明`constexpr`时用到的类型必须比较简单，我们一般称为**字面值类型**，包括算数类型，引用，指针，自定义类型，IO库，String等不属于字面值类型。

`constexpr`指针的初始值必须是nullptr或者0，或者是存储与某个固定地址的对象。

`constexpr`指针不能指向函数体内定义的变量，因为这种变量一般不是存放在固定的地址中。`constexpr`指针可以指向定义在函数体外的变量。

**指针和constexpr**

限定符`constexpr`仅仅对指针有效，与指针所指的对象无关。相当于是顶层的const。
```c++
// i和j都必须定义在函数体之外
constexpr const int *p = &i;  // 常量指针，并且指向的对象也是常量
constexpr int *p1 = &j;  // 常量指针，指向普通变量，可以通过p1改变所指向对象的值
```

## 2.5 处理类型
为了应对程序中类型名越来越复杂的问题

### 2.5.1 类型别名
类型别名是一个名字，它是某种类型的同义词。

有两种方法定义类型别名：

1. 使用关键字`typedef`
```c++
typedef double wages;
typedef wages base, *p;  // p是double*的别名
``` 
2. 使用别名声明
```c++
using SI = Sales_item;
``` 

**指针、常量和类型别名**

如果某个类型别名指代的是复合类型或者常量，那么把它用到声明语句里就会产生意想不到的后果。
```c++
typedef char *pstring;
const pstring cstr = 0;
``` 

上述定义的变量`cstr`是一个指向`char`的常量指针。这里有一个理解误区，很容易会将上述语句理解为
```c++
const char *cstr = 0;
``` 
这两种声明的差别在于：
- 声明语句使用`pstring`，基本数据类型是指针
- 声明语句使用`char *`，基本数据类型是`char`

### 2.5.2 auto类型说明符
`auto`类型说明符能够让编译器去分析表达式所属的类型，`auto`定义的变量必须有初始值。
```c++
auto sz = 0, pi = 3.14;  // 错误，sz和pi的数据类型不一样
``` 

**复合类型、常量和auto**

编译器推断出来的`auto`类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。
- 编译器会以引用对象的类型作为`auto`的类型
- `auto`一般会忽略顶层`const`，保留底层`const`
- 如果希望推断的`auto`类型是顶层`const`，需要明确指出
- 可以将引用的类型设为`auto`，此时初始值中的顶层常量属性仍然保留
```c++
int i = 0, &r = i;
auto a = r;  // a是一个int类型

const int ci = i; &cr = ci;
auto b = ci;  // b是一个int类型，顶层const被忽略
auto c = cr;  // c是一个int类型
auto d = &i;  // d是一个int类型的指针
auto e = &ci;  // e是一个指向const int类型的指针

const auto f = ci;  // f是一个const int类型

auto &g = ci;  // g是一个整型常量引用
auto &h = 42;  // 错误，不能为非常量引用绑定字面值常量
const auto &j = 42;  // 正确，可以为常量引用绑定字面值常量
``` 

### 2.5.3 decltype类型指示符

当希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。这时候使用第二种类型说明符`decltype`，它的作用是选择并返回操作数的数据类型。编译器分析表达式并得到他的类型，却不实际计算表达式的值。
```c++
decltype(f()) sum = x;  // sum的类型就是函数f的返回类型
```
`decltype`处理顶层const的方式与auto不同，如果`decltype`使用的表达式是一个变量，则`decltype`返回该变量的类型，包括顶层const和引用在内。

需要注意的是，引用从来都是作为所指对象的同义词出现，只有用在`decltype`处是一个例外。

**`decltype`和引用**

如果表达式的内容是解引用操作，则`decltype`将得到引用类型。
```c++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b;  // r + 0 是一个int类型
decltype(*p) c; // 错误，decltype(*p)结果是int &,必须要初始化
```

对于`decltype`所用的表达式来说，如果变量名加上一对括号，则得到的类型与不加括号时会有不同。

如果给变量多加了一层或多层括号，编译器会把它当做是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的`decltype`就会得到引用类型。

`decltype((variable))`的结果永远是引用。

## 2.6 自定义数据结构
数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。

### 2.6.1 定义Sale_data类型

Sale_data初步定义如下：
```c++
struct Sale_data{
    std::string bookNo;
    unsigned unit_sold = 0;
    double revenue = 0.0;
};
```
类体右侧表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名表示对该类型对象的定义。
```c++
struct Sale_data{
   
} accum, trans, *salesptr;

// 这种定义类对象的方式与上面相同
struct Sales_data{ };
Sales_data accum, trans, *salesptr;
```

最好不要将对象的定义和类的定义放在一起。

**类数据成员**

C++11新标准规定，可以为数据成员提供一个**类内初始值**。

### 2.6.2 使用Sales_data类
- 添加两个Sales_data对象
- Sales_data对象读入数据
- 输出两个Salse_data对象的和

### 2.6.3 编写自己的头文件

为了确保各个文件中类的定义一直，类通常被定义在头文件中，而且类所在头文件的名字应该与类名一样。

如果头文件中包含了其他头文件，程序中可能会多次包含同一个头文件。为了避免程序中多次包含同一个头文件，书写头文件时需要做一些处理。

**预处理器概念**

确保头文件多次包含仍能安全工作的常用技术是预处理器，它是在编译之前执行的一段程序，例如之前用到的`#include`。

还会用到的一项预处理功能是**头文件保护符**，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。
1. `#define`指令将一个名字设为预处理变量
2. `#ifdef`当且仅当变量已定义时为真
3. `#ifndef`当且仅当变量未定义时为真
4. 只有当检查结果为真才会执行后续操作，直到遇到`#endif`

预处理变量无视C++中关于作用域的规则。

整个程序中的预处理保护符必须唯一，基于头文件中类的名字来构建保护符的名字以确保其唯一性，名字全部大写。

所有的头文件都要加上保护符，不管有没有被包含在其他头文件中。