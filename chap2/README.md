# 第2章 变量和基本类型



## 2.1 基本内置类型

C++定义了两种基本数据类型，**算术类型**和**空类型**。

### 2.1.1 算术类型

算术类型分为两类，**整型**和**浮点型**。

算术类型的尺寸在不同机器上有所差别。

|    类型     |      含义      |   最小尺寸    |
| :---------: | :------------: | :-----------: |
|    bool     |    布尔类型    |    未定义     |
|    char     |      字符      | 8位（1字节）  |
|   wchar_t   |     宽字符     | 16位（2字节） |
|  char16_t   |  Unicode字符   | 16位（2字节） |
|  char32_t   |  Unicode字符   | 32位（4字节） |
|    short    |     短整型     | 16位（2字节） |
|     int     |      整型      | 16位（2字节） |
|    long     |     长整型     | 32位（4字节） |
|  long long  |     长整型     | 64位（8字节） |
|    float    |  单精度浮点型  |  6位有效数字  |
|   double    |  双精度浮点数  | 10位有效数字  |
| long double | 扩展精度浮点数 | 10位有效数字  |

一个char的空间确保可以存放机器基本字符集中任意字符对应的数字值。

对于扩展字符集，使用wchar_t等。

**带符号类型和无符号类型**

除了布尔型和扩展的字符集，其他整型都可以划分为**带符号（signed）**和**无符号（unsigned）**两种。

- 类型int shot long 和long long都是带符号的，类型名前面加上unsigned就是无符号类型。
- 字符型被分为三种，char、signed char和unsigned char。char具体是有符号还是无符号由编译器决定。

**数据类型选取建议**

- 尽量使用无符号类型。
- 如果数值超过int，使用long long。
- 算术表达式中不用char和bool。如果需要不大的整数，给char指明是否带符号。
- 执行浮点数计算使用double。

### 2.1.2 类型转换

算术类型转换过程中需要注意以下几点：

- 将整数转换为浮点数，通常小数部分记为0。如果整数所占空间超过了浮点数，整数精度可能会损失。
- 不能赋给无符号类型一个超出它表示范围的值。否则结果是初始值对无符号类型表示数值总数取模后的余数。
- 如果赋给带符号类型一个超出它表示范围的值，结果是未定义的。

**含有无符号类型的表达式**

如果一个算术表达式中既有带符号也有无符号，带符号数会自动被转换为无符号数，这也相当于将带符号整数赋值给无符号，这样会得到不符合预期的结果。因此，**不要在表达式中混用带符号和无符号数。**

### 2.1.3 字面值常量

一个形如42的值被称为字面值常量。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

**整型和浮点型字面值**

- 整型字面值可以用十进制，八斤重、十六进制数来表示。0开头的用来表示八进制，0x或者0X开头表示十六进制。

- 浮点型字面值可以由小数或者科学计数法的形式来表现，浮点型字面值默认是一个double。

**字符和字符串字面值**

- 单引号括起来的一个字符表示字符字面值。
- 双引号括起来的表示字符串字面值，实际上是由常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符'\0'。
- 两个字符串字面值由空格、缩进和换行分隔，实际上是一个字符串。

**转义序列**

遇到**不可打印**以及有**特殊含义**的字符，就需要使用转义序列，转义序列均以反斜线作为开始。

- 换行符  \n
- 横向制表符 \t
- 反斜线 \\\  等等

在程序中，上述转义序列被当作一个字符使用。

还可以使用泛化的转义序列，\x后紧跟十六进制数字（一个或者多个），\后紧跟八进制数字（最多三个），数字部分表示的是字符对应的数值。

**指定字面值类型**

可以在字面值常量上面加上前缀或者后缀，指定其对应的数据类型。

## 2.2 变量

变量提供一个具名的、可供程序操作的存储空间。

### 2.2.1 变量定义

**初始值**

当对象在创建时获得初始值，我们说这个对象被**初始化**了。在同一条定义语句中，可以用先定义的变量去初始化后定义的变量。

**注意**：初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象当前值擦除，以一个新值代替。

**列表初始化**

C++定义了初始化的多种形式，以下4条语句都可以初始化一个int类型的变量：

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

用花括号初始化变量称为列表初始化。这种初始化方式有一个特点：如果使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。

**默认初始化**

如果定义变量时没有指定初值，则变量被默认初始化。对于内置类型而言，定义于任何函数之外的变量被初始化为0，定义于函数体内部的变量**不被初始化**。类的对象如果没有显式地初始化，其值由类决定。

### 2.2.2 变量声明和定义的关系

**声明**使得名字为程序所知，**定义**负责创建与名字关联的实体。变量声明规定了变量的类型和名字，定义还需要申请存储空间，也可能会为变量赋一个初始值。

```c++
extern int i;  // 声明，extern用来显式地声明变量
int j;  // 声明并定义
extern double pi = 3.1416;  // 定义，显示初始化变量会抵消extern的作用
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

变量只能被定义一次，但可以被多次声明。

### 2.2.3 标识符

C++的标识符由字母、数字和下划线组成，并且必须由字母或者下划线开头。长度没有限制，对大小写敏感。

用户自定义的标识符还有一些注意事项：

- 不能连续出现两个下划线
- 不能以下划线紧连大写字母开头
- 定义在函数体以外的标识符不能以下划线开头

### 2.2.4 名字的作用域

作用域是程序的一部分，在其中名字有其特定的含义。C++中大多数作用域都是以花括号分割。

名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

定义在函数体外的名字拥有**全局作用域**，定义在函数体内部的名字有**块作用域**。

建议：一般来说，在对象第一次被使用的地方附近定义它是一种好的选择。

**嵌套的作用域**

作用域能彼此包含，被包含的作用域称为**内层作用域**，包含着别的作用域的作用域称为**外层作用域**。

可以通过域操作符`::`显示地访问全局变量。

